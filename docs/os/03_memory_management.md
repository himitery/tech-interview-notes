# Memory Management

## ✅ 메모리 관리의 목적

- 한정된 메모리를 효율적으로 분배
- 메모리 낭비 최소화
- 사용자 프로그램 간의 보호와 격리
- 프로세스 간 주소 공간 충돌 방지

## ✅ 주소 공간

- **논리 주소(Logical Address)**: CPU가 생성한 주소 (가상 주소)
- **물리 주소(Physical Address)**: 실제 메모리의 주소
- MMU(Memory Management Unit)가 논리 주소를 물리 주소로 변환함

## ✅ 연속 할당 방식

- 고정 분할: 메모리를 미리 정해진 크기로 나눔
- 가변 분할: 프로세스 크기에 맞춰 동적으로 할당

### 단편화

- **내부 단편화**: 할당된 공간 중 일부가 낭비되는 현상
- **외부 단편화**: 할당되지 않은 공간이 조각나서 사용이 불가능한 상태

## ✅ 가상 메모리

- 물리 메모리보다 큰 주소 공간을 제공하기 위한 기법
- 필요할 때만 메모리에 적재 (Demand Paging)
- 디스크 공간을 이용한 확장 → 스왑 영역(Swap Space) 활용

### 장점

- 프로그램 실행 시 전체를 메모리에 올릴 필요 없음
- 다수 프로그램 동시 실행 가능 (멀티태스킹)

## ✅ 페이징(Paging)

- 메모리를 고정 크기 블록(Page/Frame) 단위로 나눠 관리
- 프로세스는 페이지 단위, 물리 메모리는 프레임 단위로 분리

### 페이지 테이블

- 페이지 번호 → 프레임 번호 매핑 정보 저장
- 각 프로세스마다 별도의 페이지 테이블 가짐

### 페이지 폴트(Page Fault)

- 참조한 페이지가 메모리에 없는 경우 발생
- 디스크에서 페이지를 불러와 메모리에 적재 후 재실행

### TLB(Translation Lookaside Buffer)

- 자주 참조되는 페이지 테이블 항목을 캐싱
- 주소 변환 속도 향상

## ✅ 세그멘테이션(Segmentation)

- 메모리를 논리적 단위(코드, 데이터, 스택 등)로 분할
- 각 세그먼트는 크기가 다르고, 시작 주소와 길이로 관리

### 페이징 vs 세그멘테이션

| 구분        | 페이징           | 세그멘테이션          |
| ----------- | ---------------- | --------------------- |
| 단위        | 고정 크기 Page   | 가변 크기 Segment     |
| 사용자 관점 | 비직관적         | 논리적 단위와 일치    |
| 단편화      | 내부 단편화 발생 | 외부 단편화 발생 가능 |

## ✅ 혼합 기법

- **세그먼트 기반 페이징**: 각 세그먼트를 다시 페이지로 나눠서 관리
- 효율성과 유연성을 동시에 확보할 수 있는 방법

## ✅ 스와핑(Swapping)

- 메모리 부족 시, 전체 프로세스를 디스크로 이동시켜 메모리를 확보
- 오버헤드가 크기 때문에 현대 시스템에서는 페이지 교체 방식이 일반적

## ✅ 페이지 교체 알고리즘

- **FIFO**: 가장 먼저 들어온 페이지 제거
- **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지 제거
- **Optimal**: 앞으로 가장 오랫동안 사용되지 않을 페이지 제거 (이론적 최적)

## ✅ 실무 관점에서 고려사항

- 메모리 접근 패턴을 고려한 구조 설계 필요
- 캐시, 버퍼, 메모리 풀 등을 통한 성능 최적화
- GC가 있는 언어(Java 등)에서는 Heap 크기 및 GC 전략이 중요
